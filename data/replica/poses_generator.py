import os
import numpy as np
from tools.helpers_tools import r_x, r_y, r_z
import torch
# from data.hypersims.processing.ins_centers import ins_center_loader
import json

ins_centers = {'bathroom': [0.779178, 1.05247, 0.380208], 'bedroom': [-1.29552, 1.72703, 0.2946],
               'dinningroom': [-0.633653, 0.295162, 0.279743], 'kitchen': [-2.52579, -0.103821, 1.47165],
               'livingroom_reception': [0.579352, -0.099242, 0.092597],
               'livingroom_rest': [-0.001277, -2.85079, 0.588084],
               'office_reception': [-0.717374, 0.929292, 0.904515],
               'office_study': [-0.519422, -2.16509, 1.07392]}

ins_centers_replica = {'57': [1.7759442329406738, 0.6290670037269592, -1.2724769115447998],
                       '73': [3.7623934745788574, 0.774434506893158, -1.2633039951324463]}


def generate_poses(args, defined_transformations=None):
    """pose also can generated by yourself or selected from the data set"""
    # import you self designed transformation matrix
    transformations = {}
    save_path = os.path.join(args.datadir, 'transformation_matrix.json')
    poses_list = []
    if defined_transformations is not None:
        """this branch for the new target poses you support"""
        pass
    else:
        # ins_centers = ins_center_loader(args)

        ins_center = np.array(ins_centers_replica[str(args.target_label)])
        print(ins_center)
        # ins_center = ins_centers[args.center_index]
        translation = np.eye(4, 4, dtype=np.float32)
        translation[:3, -1] = -1 * ins_center
        translation_inverse = np.eye(4, 4, dtype=np.float32)
        translation_inverse[:3, -1] = -1 * translation[:3, -1]
        if args.editor_mode == 'translation':
            t = np.array([[1, 0, 0, -0.15],
                          [0, 1, 0, 0],
                          [0, 0, 1, 0],
                          [0, 0, 0, 1]])
            tar_pose = translation_inverse @ t @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'translation'})
            poses_list.append(pose_dict)
        if args.editor_mode == 'rotation':
            'self rotation'
            roll = np.zeros(1)
            pitch = np.zeros(1)
            yaw = np.array([30 * np.pi / 180])
            r = r_z(yaw[0]) @ r_y(pitch[0]) @ r_x(roll[0])
            tar_pose = translation_inverse @ r @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'rotation'})
            poses_list.append(pose_dict)
        if args.editor_mode == 'scale':
            scales = np.array([1.1])
            for i in range(len(scales)):
                s = np.array([[scales[i], 0, 0, 0],
                              [0, scales[i], 0, 0],
                              [0, 0, scales[i], 0],
                              [0, 0, 0, 1]])
                tar_pose = translation_inverse @ s @ translation
                pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'scale'})
                poses_list.append(pose_dict)
        if args.editor_mode == 'multi':
            scales = np.array([1.1])

            s = np.array([[scales[0], 0, 0, 0],
                          [0, scales[0], 0, 0],
                          [0, 0, scales[0], 0],
                          [0, 0, 0, 1]])

            roll = np.zeros(1)
            pitch = np.zeros(1)
            yaw = np.array([30 * np.pi / 180])
            r = r_z(yaw[0]) @ r_y(pitch[0]) @ r_x(roll[0])
            multi_transforamtion = r @ s

            distance = - 0.1
            t = np.array([[1, 0, 0, -0.15],
                          [0, 1, 0, 0],
                          [0, 0, 1, 0],
                          [0, 0, 0, 1]])

            multi_transforamtion = multi_transforamtion @ t
            tar_pose = translation_inverse @ multi_transforamtion @ translation
            pose_dict = dict({'transformation': tar_pose.tolist(), 'mode': 'multi'})
            poses_list.append(pose_dict)
    transformations.update({'transformations': poses_list})
    with open(save_path, 'w') as fp:
        json.dump(transformations, fp, ensure_ascii=False, indent=2)
    fp.close()

    return transformations
